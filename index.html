<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>8105 Tour 2025</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            color: #333;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 1rem;
            display: flex; /* Use flexbox for overall layout */
            flex-direction: column; /* Stack children vertically */
            min-height: 98vh; /* Ensure container takes full viewport height */
        }
        .card {
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e2e8f0; /* Light border */
        }
        .input-group {
            margin-bottom: 1rem;
        }
        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #4a5568; /* Darker gray for labels */
        }
        .input-field {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e0; /* Light gray border */
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #2d3748; /* Dark text for inputs */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-field:focus {
            outline: none;
            border-color: #4299e1; /* Blue border on focus */
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5); /* Blue shadow on focus */
        }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            text-align: center;
            white-space: nowrap;
            border: none;
        }
        .btn-primary {
            background-color: #4299e1; /* Blue */
            color: #ffffff;
            box-shadow: 0 4px 6px rgba(66, 153, 225, 0.3);
        }
        .btn-primary:hover {
            background-color: #3182ce; /* Darker blue */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Light gray */
            color: #2d3748;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .btn-secondary:hover {
            background-color: #cbd5e0; /* Darker light gray */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444; /* Red */
            color: #ffffff;
            box-shadow: 0 4px 6px rgba(239, 68, 68, 0.3);
        }
        .btn-danger:hover {
            background-color: #dc2626; /* Darker red */
            transform: translateY(-1px);
        }
        .table-container {
            overflow-x: auto;
            margin-top: 1.5rem;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.95rem;
        }
        th, td {
            padding: 0.75rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
            white-space: nowrap; /* Prevent wrapping in table cells */
        }
        th {
            background-color: #f7fafc; /* Lighter background for headers */
            font-weight: 700;
            color: #2d3748;
            position: sticky; /* Sticky header for horizontal scroll */
            left: 0;
            z-index: 10;
        }
        td:first-child, th:first-child {
            position: sticky;
            left: 0;
            background-color: inherit; /* Ensure background matches parent */
            z-index: 1; /* Keep player names visible */
        }
        td:first-child {
            font-weight: 600;
        }
        .score-input {
            width: 60px; /* Fixed width for score inputs */
            text-align: center;
            padding: 0.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.5rem;
            font-size: 0.9rem;
        }
        .score-input:focus {
            outline: none;
            border-color: #4299e1;
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.3);
        }
        .leaderboard-table th, .leaderboard-table td {
            text-align: center;
        }
        .leaderboard-table td:first-child, .leaderboard-table th:first-child {
            text-align: left;
            position: static; /* No sticky for leaderboard */
        }
        .leaderboard-table tr:nth-child(odd) {
            background-color: #fbfdff; /* Zebra striping */
        }
        .leaderboard-table tr:hover {
            background-color: #edf2f7; /* Hover effect */
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            z-index: 1010; /* Erhöhter z-index für Pop-ups */
            text-align: center;
            max-width: 90%;
            border: 1px solid #e2e8f0;
            max-height: 80vh; /* Added: Max height for scrollability */
            overflow-y: auto; /* Added: Enable vertical scrolling */
        }
        .message-box-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        #messageBox { z-index: 1020; } /* Stellt sicher, dass die Standard-MessageBox immer oben ist */
        #passwordModal { z-index: 1010; }
        #tournamentAdminModal { z-index: 1000; }

        .message-box h3 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: #2d3748;
        }
        .message-box p {
            margin-bottom: 1.5rem;
            color: #4a5568;
        }
        /* New style for the bottom button container */
        .bottom-button-container {
            margin-top: auto; /* Pushes the container to the bottom */
            padding-top: 1.5rem; /* Add some space above the button */
            display: flex;
            justify-content: center;
            gap: 1rem;
        }

        /* Styles for the custom password modal */
        #passwordModal input {
            width: calc(100% - 2rem); /* Account for padding */
            padding: 0.75rem 1rem;
            margin-bottom: 1.5rem;
            border: 1px solid #cbd5e0;
            border-radius: 0.5rem;
            font-size: 1rem;
            text-align: center;
        }
        #passwordModal .button-group {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .sync-status {
            transition: all 0.3s ease-in-out;
        }

        /* ++ NEUE STILE FÜR SCORE-EINGABE ++ */
        .score-stepper {
            display: flex;
            align-items: center;
            justify-content: center; /* Zentriert die +/-/Input Gruppe in der Tabellenzelle */
        }
        .stepper-btn {
            width: 32px;
            height: 32px;
            border: 1px solid #cbd5e0;
            background-color: #f7fafc;
            font-size: 1.2rem;
            font-weight: bold;
            color: #4a5568;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1; /* Stellt sicher, dass das Zeichen vertikal zentriert ist */
        }
        .stepper-btn:hover {
            background-color: #e2e8f0;
        }
        .stepper-btn.minus {
            border-radius: 0.5rem 0 0 0.5rem;
        }
        .stepper-btn.plus {
            border-radius: 0 0.5rem 0.5rem 0;
        }
        /* Anpassungen für das Score-Input-Feld, wenn es im Stepper ist */
        .player-score-input {
            width: 50px; /* Etwas schmaler, um Platz für Buttons zu machen */
            border-left: none;
            border-right: none;
            border-radius: 0;
            -moz-appearance: textfield; /* Versteckt Standard-Pfeile in Firefox */
        }
        /* Versteckt Standard-Pfeile in Chrome/Safari */
        .player-score-input::-webkit-outer-spin-button,
        .player-score-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

    </style>
</head>
<body class="p-4">
    <div class="container">
        <h1 id="title" class="text-3xl font-bold text-center mb-2 text-gray-800">Turniername</h1>
        <h3 id="title2" class="text-xl text-center mb-6 text-gray-600">8105 Tour 2025</h3>

        <!-- Mode Selection & Info Box -->
        <div class="card flex flex-col sm:flex-row justify-between items-center gap-4 mb-6">
            <div id="infoBox" class="text-center sm:text-left">
                <div id="courseInfoBox" class="hidden">
                    <p id="courseNameInfo" class="font-bold text-gray-700"></p>
                    <p id="courseRatingsInfo" class="text-sm text-gray-500"></p>
                </div>
                 <div id="playerInfoBox" class="hidden mt-2">
                    <p id="playerNameInfo" class="font-bold text-blue-600"></p>
                    <p id="playerEhcInfo" class="text-sm text-gray-500"></p>
                </div>
            </div>
            <button id="playerModeBtn" class="btn btn-primary flex-shrink-0">Spieler-Modus</button>
        </div>

        <!-- Nachrichtenbox für Bestätigungen/Fehler -->
        <div id="messageBox" class="hidden message-box">
            <h3 id="messageBoxTitle" class="font-bold"></h3>
            <p id="messageBoxContent"></p>
            <button id="messageBoxCloseBtn" class="btn btn-primary">OK</button>
        </div>
        <div id="messageBoxOverlay" class="hidden message-box-overlay"></div>

        <!-- Custom Password Modal -->
        <div id="passwordModal" class="hidden message-box">
            <h3>Passwort</h3>
            <input type="password" id="passwordInput" placeholder="Passwort eingeben">
            <div class="button-group">
                <button id="passwordSubmitBtn" class="btn btn-primary">Bestätigen</button>
                <button id="passwordCancelBtn" class="btn btn-secondary">Abbrechen</button>
            </div>
        </div>

        <!-- NEU: Turnierverwaltung Modal -->
        <div id="tournamentAdminModal" class="hidden message-box">
            <h3 class="font-bold">Turnierverwaltung</h3>
            <div class="card">
                <h4 class="text-lg font-semibold mb-2 text-gray-700">A. Neues Turnier erstellen</h4>
                <div class="input-group">
                    <label for="newTournamentNameInput">Name des neuen Turniers:</label>
                    <input type="text" id="newTournamentNameInput" class="input-field" placeholder="z.B. Season Opener">
                </div>
                <button id="createTournamentBtn" class="btn btn-primary w-full">Erstellen & als Live-Turnier setzen</button>
            </div>
            <div class="card">
                 <h4 class="text-lg font-semibold mb-2 text-gray-700">B. Gespeichertes Turnier laden/löschen</h4>
                 <div class="input-group">
                     <label for="loadTournamentSelect">Gespeichertes Turnier:</label>
                     <select id="loadTournamentSelect" class="input-field"></select>
                </div>
                <div class="flex gap-4">
                    <button id="loadTournamentBtn" class="btn btn-secondary w-2/3">Als Live-Turnier laden</button>
                    <button id="deleteTournamentBtn" class="btn btn-danger w-1/3">Löschen</button>
                </div>
            </div>
             <button id="closeAdminModalBtn" class="btn btn-secondary mt-4">Schliessen</button>
        </div>


        <!-- Organisator-Modus Inhalte -->
        <div id="organizerContent" class="hidden"> <!-- Initially hidden -->
            <!-- Turnier- und Platz-Setup -->
            <div class="card">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">1. Turnier & Platz Einstellungen</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="input-group">
                        <label for="tournamentName">Turniername:</label>
                        <input type="text" id="tournamentName" class="input-field" placeholder="Mein Golfturnier">
                    </div>
                    <div class="input-group">
                        <label for="courseName">Golfplatzname:</label>
                        <input type="text" id="courseName" class="input-field" placeholder="Golfpark Zürich">
                    </div>
                    <div class="input-group">
                        <label for="courseRating">Course Rating (CR):</label>
                        <input type="number" step="0.1" id="courseRating" class="input-field" value="72.0" min="50" max="80">
                    </div>
                    <div class="input-group">
                        <label for="slopeRating">Slope Rating (SR):</label>
                        <input type="number" id="slopeRating" class="input-field" value="120" min="55" max="155">
                    </div>
                </div>

                <h3 class="text-lg font-semibold mt-6 mb-3 text-gray-700">Loch-Details (Par & Handicap Index)</h3>
                <div class="table-container">
                    <table id="courseDetailsTable">
                        <thead>
                            <tr>
                                <th>Loch</th>
                                <!-- Generate headers for holes 1-18 -->
                                <script>
                                    for (let i = 1; i <= 18; i++) {
                                        document.write(`<th>#${i}</th>`);
                                    }
                                </script>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Par</td>
                                <!-- Input fields for Par -->
                                <script>
                                    for (let i = 1; i <= 18; i++) {
                                        document.write(`<td><input type="number" id="par${i}" class="score-input" value="4" min="3" max="5"></td>`);
                                    }
                                </script>
                            </tr>
                            <tr>
                                <td>HCP Index</td>
                                <!-- Input fields for Handicap Index -->
                                <script>
                                    for (let i = 1; i <= 18; i++) {
                                        document.write(`<td><input type="number" id="hcpIndex${i}" class="score-input" value="${i}" min="1" max="18"></td>`);
                                    }
                                </script>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <button id="saveCourseBtn" class="btn btn-primary mt-4 w-full">Platz-Einstellungen speichern</button>
            </div>

            <!-- NEU: Turniersteuerung -->
            <div class="card">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Turniersteuerung</h2>
                <div class="flex flex-col space-y-4">
                    <div class="flex items-center justify-between">
                        <label for="lockScoresToggle" class="text-gray-600">Score-Eingabe für Spieler sperren</label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="lockScoresToggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                    <div class="flex items-center justify-between">
                        <label for="showLiveScoreToggle" class="text-gray-600">Live Score für Spieler anzeigen</label>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="showLiveScoreToggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-4 peer-focus:ring-blue-300 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Spieler hinzufügen -->
            <div class="card">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">2. Spieler hinzufügen</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div class="input-group">
                        <label for="playerName">Spielername:</label>
                        <input type="text" id="playerName" class="input-field" placeholder="Max Mustermann">
                    </div>
                    <div class="input-group">
                        <label for="playerHandicap">Handicap Index (HCI):</label>
                        <input type="number" step="0.1" id="playerHandicap" class="input-field" value="18.0" min="0" max="54">
                    </div>
                </div>
                <button id="addPlayerBtn" class="btn btn-primary w-full mt-4">Spieler hinzufügen</button>

                <h3 class="text-lg font-semibold mt-6 mb-3 text-gray-700">Aktuelle Spieler</h3>
                <div class="table-container">
                    <table id="playersTable">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>HCI</th>
                                <th>Spielvorgabe</th>
                                <th>Aktionen</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Spieler werden hier dynamisch eingefügt -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Ergebnisse eingeben (Organisator-Ansicht) -->
            <div class="card">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">3. Ergebnisse eingeben (Organisator)</h2>
                <p class="text-gray-600 mb-4">Geben Sie die Brutto-Schlagzahlen für jeden Spieler und jedes Loch ein.</p>
                <div class="table-container">
                    <table id="scoresTable">
                        <thead>
                            <tr>
                                <th>Spieler</th>
                                <!-- Generate headers for holes 1-18 -->
                                <script>
                                    for (let i = 1; i <= 18; i++) {
                                        document.write(`<th>Loch ${i}</th>`);
                                    }
                                </script>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Spieler-Reihen werden hier dynamisch eingefügt -->
                        </tbody>
                    </table>
                </div>
                <button id="calculateScoresBtn" class="btn btn-primary w-full mt-4">Ergebnisse berechnen & Rangliste erstellen</button>
            </div>
        </div> <!-- End of organizerContent -->

        <!-- Spieler-Modus Inhalte -->
        <div id="playerContent"> <!-- Initially visible -->
            <div class="card">
                <!-- NEU: Statusmeldung für gesperrte Eingabe -->
                <div id="scoreLockMessage" class="hidden bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4 rounded-md" role="alert">
                    <p class="font-bold">Hinweis</p>
                    <p>Die Score-Eingabe ist momentan vom Turnier-Organisator gesperrt.</p>
                </div>

                <h2 class="text-xl font-semibold mb-4 text-gray-700" id="playerWelcomeMessage"></h2>
                <div class="input-group">
                    <label for="playerSelect">Wähle Deinen Namen:</label>
                    <select id="playerSelect" class="input-field">
                        <option value="">-- Spieler auswählen --</option>
                    </select>
                </div>
                <button id="playerLoginBtn" class="btn btn-primary w-full mt-4">Anmelden</button>

                <h3 class="text-lg font-semibold mt-6 mb-3 text-gray-700">Deine Ergebnisse eingeben</h3>
                <div class="table-container">
                    <table id="playerScoresTable" class="w-full text-sm">
                        <thead>
                            <tr class="text-xs text-gray-700 uppercase bg-gray-50">
                                <th class="px-3 py-2 text-center">#</th>
                                <th class="px-3 py-2 text-center">PAR</th>
                                <th class="px-3 py-2 text-center">HCP /</th>
                                <th class="px-3 py-2 text-center">SCORE</th>
                            </tr>
                        </thead>
                        <tbody id="playerScoresTableBody">
                            <!-- Rows will be inserted by JS -->
                        </tbody>
                        <tfoot class="font-bold bg-gray-100">
                             <tr>
                                <td colspan="3" class="px-3 py-2 text-right">STROKES:</td>
                                <td id="playerTotalScore" class="px-3 py-2 text-center">0</td>
                             </tr>
                        </tfoot>
                    </table>
                </div>

                <div class="flex flex-col sm:flex-row gap-4 mt-4 items-center">
                    <button id="syncScoresBtn" class="btn btn-primary w-full sm:w-1/2">Manuell Synchronisieren</button>
                    <button id="playerSaveScoresBtn" class="btn btn-secondary w-full sm:w-1/2">Meine Scorecard</button>
                </div>
                 <div class="text-center mt-2">
                    <span id="syncStatus" class="text-sm text-gray-500 sync-status"></span>
                 </div>
                <button id="liveScoreBtn" class="btn bg-green-700 hover:bg-green-800 text-white w-full mt-4">Live Score</button>
            </div>
        </div> <!-- End of playerContent -->

        <!-- Rangliste (in beiden Modi sichtbar, aber Reset nur für Organisator) -->
        <div class="card" id="leaderboardCard">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">4. Rangliste</h2>
            <div class="table-container">
                <table id="leaderboardTable" class="leaderboard-table">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Spieler</th>
                            <th>SF</th>
                            <th>PHC</th>
                            <th>EHC</th>
                            <th>Strokes</th>
                            <th>Brutto</th>
                            <th>Netto</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Rangliste wird hier dynamisch eingefügt -->
                    </tbody>
                </table>
            </div>
            <div class="flex flex-col sm:flex-row gap-4 mt-4">
                <button id="organizerSyncBtn" class="btn bg-green-700 hover:bg-green-800 text-white w-full sm:w-1/2 organizer-only">Synchronisieren</button>
            </div>
        </div>

        <!-- Organisator-Modus Knopf ganz unten -->
        <div class="bottom-button-container">
            <button id="playerModeBtnBottom" class="btn btn-secondary">Spieler-Modus</button>
            <button id="tournamentAdminBtn" class="btn btn-secondary">Turniere</button>
            <button id="organizerModeBtnBottom" class="btn btn-secondary">Organisator-Modus</button>
        </div>
    </div>

    <script type="module">
        // ===================================================================================
        // FIREBASE & APP INITIALIZATION
        // ===================================================================================
        import { initializeApp, getApps } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, query, addDoc, getDocs, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-analytics.js";

        // Globale Variablen für App-Zustand und Firebase-Instanzen
        let app, db, auth;
        let authReady = false;
        let tournamentsCollectionRef; // Referenz zur Sammlung aller Turniere
        let tournamentDocRef; // Referenz zum aktuell geladenen Turnier-Dokument
        let activeTournamentStateRef;
        let currentTournamentId = null; // ID des aktuellen Turniers
        let course = {}; // Speichert die aktuellen Platzdaten (CR, SR, Pars etc.)
        let players = []; // Array aller Spieler
        let scores = {}; // Objekt, das die Scores aller Spieler speichert { playerId: { hole1: score, ... } }
        let settings = { isScoreEntryLocked: false, isLiveScoreVisible: true }; // Speichert globale Turniereinstellungen
        let unsubscribeTournament; // Funktion zum Abbestellen des Tournament-Listeners
        let unsubscribePlayers;
        let unsubscribeActiveState;
        let debounceTimer; // Timer für das automatische Speichern

        // Globale UI-Zustandsvariablen
        let currentMode = 'player'; // Aktueller Modus ('player' oder 'organizer')
        let activePlayerId = null; // ID des aktuell angemeldeten Spielers
        let organizerSessionActive = false; // Ob die Organisator-Session aktiv ist
        const ORGANIZER_PASSWORD = "8105"; // Simples Passwort für den Organisator-Modus

        // Firebase-Konfiguration
        const firebaseConfig = {
            apiKey: "AIzaSyCk-XEKnnWqRlTqVXUFCxGc69JpmhErIT8",
            authDomain: "rgnt-8105-stableford.firebaseapp.com",
            projectId: "rgnt-8105-stableford",
            storageBucket: "rgnt-8105-stableford.firebasestorage.app",
            messagingSenderId: "774338268555",
            appId: "1:774338268555:web:ded58e0759d42ee46d338e",
            measurementId: "G-DXQG00EWHW"
        };
        const appId = firebaseConfig.projectId;

        // ===================================================================================
        // DOM ELEMENT REFERENCES
        // ===================================================================================
        const organizerModeBtnBottom = document.getElementById('organizerModeBtnBottom');
        const playerModeBtn = document.getElementById('playerModeBtn');
        const playerModeBtnBottom = document.getElementById('playerModeBtnBottom');
        const organizerContent = document.getElementById('organizerContent');
        const playerContent = document.getElementById('playerContent');
        const leaderboardCard = document.getElementById('leaderboardCard');
        const saveCourseBtn = document.getElementById('saveCourseBtn');
        const courseDetailsTable = document.getElementById('courseDetailsTable');
        const playerNameInput = document.getElementById('playerName');
        const playerHandicapInput = document.getElementById('playerHandicap');
        const addPlayerBtn = document.getElementById('addPlayerBtn');
        const playersTableBody = document.querySelector('#playersTable tbody');
        const scoresTableBody = document.querySelector('#scoresTable tbody');
        const calculateScoresBtn = document.getElementById('calculateScoresBtn');
        const playerWelcomeMessage = document.getElementById('playerWelcomeMessage');
        const playerSelect = document.getElementById('playerSelect');
        const playerLoginBtn = document.getElementById('playerLoginBtn');
        const playerSaveScoresBtn = document.getElementById('playerSaveScoresBtn');
        const leaderboardTableBody = document.querySelector('#leaderboardTable tbody');
        const messageBox = document.getElementById('messageBox');
        const messageBoxOverlay = document.getElementById('messageBoxOverlay');
        const messageBoxTitle = document.getElementById('messageBoxTitle');
        const messageBoxContent = document.getElementById('messageBoxContent');
        const passwordModal = document.getElementById('passwordModal');
        const passwordInput = document.getElementById('passwordInput');
        const passwordSubmitBtn = document.getElementById('passwordSubmitBtn');
        const passwordCancelBtn = document.getElementById('passwordCancelBtn');
        const syncScoresBtn = document.getElementById('syncScoresBtn');
        const liveScoreBtn = document.getElementById('liveScoreBtn');
        const organizerSyncBtn = document.getElementById('organizerSyncBtn');
        const courseNameInput = document.getElementById('courseName');
        const courseRatingInput = document.getElementById('courseRating');
        const slopeRatingInput = document.getElementById('slopeRating');
        const tournamentNameInput = document.getElementById('tournamentName');
        const titleEl = document.getElementById("title");
        const titleEl2 = document.getElementById("title2");
        const syncStatusEl = document.getElementById('syncStatus');
        const lockScoresToggle = document.getElementById('lockScoresToggle');
        const showLiveScoreToggle = document.getElementById('showLiveScoreToggle');
        const scoreLockMessage = document.getElementById('scoreLockMessage');
        const courseInfoBox = document.getElementById('courseInfoBox');
        const playerInfoBox = document.getElementById('playerInfoBox');
        const courseNameInfo = document.getElementById('courseNameInfo');
        const courseRatingsInfo = document.getElementById('courseRatingsInfo');
        const playerNameInfo = document.getElementById('playerNameInfo');
        const playerEhcInfo = document.getElementById('playerEhcInfo');

        // Turnierverwaltung
        const tournamentAdminBtn = document.getElementById('tournamentAdminBtn');
        const tournamentAdminModal = document.getElementById('tournamentAdminModal');
        const closeAdminModalBtn = document.getElementById('closeAdminModalBtn');
        const newTournamentNameInput = document.getElementById('newTournamentNameInput');
        const createTournamentBtn = document.getElementById('createTournamentBtn');
        const loadTournamentSelect = document.getElementById('loadTournamentSelect');
        const loadTournamentBtn = document.getElementById('loadTournamentBtn');
        const deleteTournamentBtn = document.getElementById('deleteTournamentBtn');

        // ===================================================================================
        // UI & DISPLAY FUNCTIONS
        // ===================================================================================

        /**
         * Aktualisiert die Haupttitel der Seite.
         */
        function updatePageTitles() {
            const name = course.tournamentName || "Kein Turnier geladen";
            titleEl.textContent = name;
            titleEl2.textContent = "8105 Tour 2025";
        }

        /**
         * Aktualisiert die Info-Box mit Turnier- und Spielerdaten.
         */
        function updateInfoBox() {
            // Kurs-Info aktualisieren
            if (course && course.courseName) {
                courseNameInfo.textContent = course.courseName;
                courseRatingsInfo.textContent = `CR: ${course.courseRating} / SR: ${course.slopeRating}`;
                courseInfoBox.classList.remove('hidden');
            } else {
                courseInfoBox.classList.add('hidden');
            }

            // Spieler-Info aktualisieren
            if (activePlayerId) {
                const player = players.find(p => p.id === activePlayerId);
                if (player && course && course.pars) {
                     const totalPar = course.pars.reduce((sum, p) => sum + p, 0);
                     const playingHandicap = calculatePlayingHandicap(player.handicap, course.courseRating, course.slopeRating, totalPar);
                     playerNameInfo.textContent = player.name;
                     playerEhcInfo.textContent = `PHC: ${player.handicap.toFixed(1)} / EHC: ${playingHandicap}`;
                     playerInfoBox.classList.remove('hidden');
                }
            } else {
                playerInfoBox.classList.add('hidden');
            }
        }

       /**
         * Zeigt eine modale Nachrichtenbox an.
         * @param {string} title - Der Titel der Nachricht.
         * @param {string} content - Der Inhalt der Nachricht (kann HTML sein).
         * @param {function} [confirmCallback] - Optionaler Callback, der ausgeführt wird, wenn der "OK"-Button geklickt wird.
         */
        function showMessageBox(title, content, confirmCallback = null) {
            messageBoxTitle.textContent = title;
            messageBoxContent.innerHTML = content;
            messageBox.classList.remove('hidden');
            messageBoxOverlay.classList.remove('hidden');

            // Setzt den Z-Index des Overlays höher, damit es über dem Admin-Modal liegt, falls offen
            if (!tournamentAdminModal.classList.contains('hidden')) {
                messageBoxOverlay.style.zIndex = '1001';
            }

            let okButton = document.getElementById('messageBoxCloseBtn');
            const newOkButton = okButton.cloneNode(true);
            okButton.parentNode.replaceChild(newOkButton, okButton);
            okButton = newOkButton; // Update reference

            const action = () => {
                hideMessageBox();
                if (confirmCallback) {
                    confirmCallback();
                }
            };

            okButton.addEventListener('click', action, { once: true });
        }


        /**
         * Versteckt die modale Nachrichtenbox.
         */
        function hideMessageBox() {
            messageBox.classList.add('hidden');
            // Setzt den Z-Index des Overlays zurück, versteckt es aber nur, wenn kein anderes Modal offen ist
            messageBoxOverlay.style.zIndex = '999';
            if (passwordModal.classList.contains('hidden') && tournamentAdminModal.classList.contains('hidden')) {
                messageBoxOverlay.classList.add('hidden');
            }
        }

        /**
         * Zeigt das Passwort-Modal an.
         * @param {function} callback - Die Funktion, die nach der Passworteingabe aufgerufen wird.
         */
        function showPasswordModal(callback) {
            passwordInput.value = '';
            passwordModal.classList.remove('hidden');
            messageBoxOverlay.classList.remove('hidden');
            passwordInput.focus();
            passwordModal._submitCallback = callback;
        }

        /**
         * Versteckt das Passwort-Modal.
         */
        function hidePasswordModal() {
            passwordModal.classList.add('hidden');
             if (tournamentAdminModal.classList.contains('hidden')) {
                messageBoxOverlay.classList.add('hidden');
            }
            passwordModal._submitCallback = null;
        }

        /**
         * Zeigt/versteckt das Turnierverwaltungs-Modal.
         */
        function showTournamentAdminModal() {
            tournamentAdminModal.classList.remove('hidden');
            messageBoxOverlay.classList.remove('hidden');
            loadTournamentList();
        }

        function hideTournamentAdminModal() {
            tournamentAdminModal.classList.add('hidden');
            messageBoxOverlay.classList.add('hidden');
        }

        /**
         * Wechselt zwischen Spieler- und Organisator-Modus und passt die Sichtbarkeit der UI-Elemente an.
         * @param {string} mode - Der Zielmodus ('player' oder 'organizer').
         */
        function switchMode(mode) {
            currentMode = mode;
            localStorage.setItem('golfStablefordCurrentMode', currentMode);

            if (mode === 'organizer') {
                if (!currentTournamentId) {
                    showMessageBox("Hinweis", "Bitte zuerst ein Turnier in der Turnierverwaltung erstellen oder laden.");
                    return;
                }
                if (sessionStorage.getItem('organizerSession') === 'active') {
                    organizerSessionActive = true;
                    organizerContent.classList.remove('hidden');
                    playerContent.classList.add('hidden');
                    leaderboardCard.classList.remove('hidden');
                    playerModeBtn.classList.add('btn-secondary');
                    playerModeBtn.classList.remove('btn-primary');
                    playerModeBtnBottom.classList.add('btn-secondary');
                    playerModeBtnBottom.classList.remove('btn-primary');
                    organizerModeBtnBottom.classList.add('btn-primary');
                    organizerModeBtnBottom.classList.remove('btn-secondary');
                } else {
                    showPasswordModal((enteredPassword) => {
                        if (enteredPassword === ORGANIZER_PASSWORD) {
                            organizerSessionActive = true;
                            sessionStorage.setItem('organizerSession', 'active');
                            organizerContent.classList.remove('hidden');
                            playerContent.classList.add('hidden');
                            leaderboardCard.classList.remove('hidden');
                            playerModeBtn.classList.add('btn-secondary');
                            playerModeBtn.classList.remove('btn-primary');
                            playerModeBtnBottom.classList.add('btn-secondary');
                            playerModeBtnBottom.classList.remove('btn-primary');
                            organizerModeBtnBottom.classList.add('btn-primary');
                            organizerModeBtnBottom.classList.remove('btn-secondary');
                            showMessageBox("Erfolgreich", "Organisator-Modus aktiviert.");
                        } else {
                            showMessageBox("Zugriff verweigert", "Falsches Passwort.");
                            switchMode('player'); // Revert to player mode
                        }
                    });
                }
            } else {
                organizerContent.classList.add('hidden');
                playerContent.classList.remove('hidden');
                leaderboardCard.classList.add('hidden');
                playerModeBtn.classList.add('btn-primary');
                playerModeBtn.classList.remove('btn-secondary');
                playerModeBtnBottom.classList.add('btn-primary');
                playerModeBtnBottom.classList.remove('btn-secondary');
                organizerModeBtnBottom.classList.add('btn-secondary');
                organizerModeBtnBottom.classList.remove('btn-primary');
                if (currentTournamentId) {
                    populatePlayerSelect();
                    playerWelcomeMessage.textContent = "Bitte wählen Sie Deinen Namen und melden Sie sich an.";
                    document.getElementById('playerScoresTableBody').innerHTML = '';
                    playerSaveScoresBtn.disabled = true;
                    syncScoresBtn.disabled = true;
                }
            }
            updateInfoBox();
        }

        /**
         * Füllt das Dropdown-Menü zur Spielerauswahl mit den aktuellen Spielern.
         */
        function populatePlayerSelect() {
            playerSelect.innerHTML = '<option value="">-- Spieler auswählen --</option>';
            players.forEach(player => {
                const option = document.createElement('option');
                option.value = player.id;
                option.textContent = player.name;
                playerSelect.appendChild(option);
            });
        }

        /**
         * "Meldet" einen Spieler an, setzt den aktiven Spieler und rendert seine Score-Eingabemaske.
         * @param {string} playerId - Die ID des Spielers, der angemeldet wird.
         * @param {boolean} [showWelcomeMessage=true] - Ob eine Willkommensnachricht angezeigt werden soll.
         */
        async function loginPlayer(playerId, showWelcomeMessage = true) {
            const player = players.find(p => p.id === playerId);
            if (player) {
                activePlayerId = player.id;
                localStorage.setItem('golfStablefordActivePlayerId', activePlayerId);
                playerSelect.value = playerId;
                playerWelcomeMessage.textContent = `Willkommen, ${player.name}!`;
                renderPlayerScoresInput(player);
                playerSaveScoresBtn.disabled = false;
                syncScoresBtn.disabled = false;
                if (showWelcomeMessage) {
                    showMessageBox("Erfolgreich", `Willkommen, ${player.name}!`);
                }
            } else {
                activePlayerId = null;
                localStorage.removeItem('golfStablefordActivePlayerId');
                playerWelcomeMessage.textContent = "Bitte wählen Sie Deinen Namen und melden Sie sich an.";
                document.getElementById('playerScoresTableBody').innerHTML = '';
                playerSaveScoresBtn.disabled = true;
                syncScoresBtn.disabled = true;
                if (showWelcomeMessage) {
                    showMessageBox("Fehler", "Spieler nicht gefunden. Bitte wählen Sie einen gültigen Spieler.");
                }
            }
            updateInfoBox();
        }

        /**
         * Wendet die globalen Turniereinstellungen (z.B. Sperren) auf die UI an.
         */
        function applyTournamentSettings() {
            // Setze die Schalter im Organisator-Modus auf den korrekten Zustand
            lockScoresToggle.checked = settings.isScoreEntryLocked;
            showLiveScoreToggle.checked = settings.isLiveScoreVisible;

            // Zeige/verstecke den Live Score Button für Spieler
            liveScoreBtn.classList.toggle('hidden', !settings.isLiveScoreVisible);

            // Zeige/verstecke die Sperr-Nachricht für Spieler
            scoreLockMessage.classList.toggle('hidden', !settings.isScoreEntryLocked);

            // Rendere die Spieler-Eingabemaske neu, um den disabled-Status zu aktualisieren, falls ein Spieler angemeldet ist
            if (currentMode === 'player' && activePlayerId) {
                const player = players.find(p => p.id === activePlayerId);
                if (player) {
                    renderPlayerScoresInput(player);
                }
            }
        }

        // ===================================================================================
        // GOLF CALCULATION LOGIC
        // ===================================================================================

        /**
         * Berechnet die Spielvorgabe (Course Handicap) eines Spielers.
         * @param {number} handicapIndex - Der Handicap-Index (HCI) des Spielers.
         * @param {number} courseRating - Das Course Rating (CR) des Platzes.
         * @param {number} slopeRating - Das Slope Rating (SR) des Platzes.
         * @param {number} totalPar - Das Gesamt-Par des Platzes.
         * @returns {number} Die gerundete Spielvorgabe.
         */
        function calculatePlayingHandicap(handicapIndex, courseRating, slopeRating, totalPar) {
            const playingHandicapRaw = (handicapIndex * (slopeRating / 113)) + (courseRating - totalPar);
            return Math.round(playingHandicapRaw);
        }

        /**
         * Ermittelt die Anzahl der Vorgabeschläge für ein einzelnes Loch.
         * @param {number} playingHandicap - Die Spielvorgabe des Spielers.
         * @param {number} holeHandicapIndex - Der Handicap-Index des Lochs (1-18).
         * @returns {number} Die Anzahl der Vorgabeschläge für dieses Loch.
         */
        function getHandicapStrokesPerHole(playingHandicap, holeHandicapIndex) {
            const baseStrokes = Math.floor(playingHandicap / 18);
            const remainingStrokes = playingHandicap % 18;
            return baseStrokes + (holeHandicapIndex <= remainingStrokes ? 1 : 0);
        }

        /**
         * Berechnet die Stableford-Punkte für ein einzelnes Loch.
         * @param {number} grossScore - Der Brutto-Score des Spielers für das Loch.
         * @param {number} holePar - Das Par des Lochs.
         * @param {number} playingHandicap - Die Spielvorgabe des Spielers.
         * @param {number} holeHcpIndex - Der Handicap-Index des Lochs.
         * @returns {number} Die erzielten Stableford-Punkte.
         */
        function calculateStablefordPoints(grossScore, holePar, playingHandicap, holeHcpIndex) {
            if (isNaN(grossScore) || grossScore <= 0) return 0; // Null oder weniger zählt nicht
            const netStrokesForHole = getHandicapStrokesPerHole(playingHandicap, holeHcpIndex);
            const netParForHole = holePar + netStrokesForHole;
            return Math.max(0, 2 + (netParForHole - grossScore));
        }

        /**
         * Formatiert einen Score relativ zu Par (z.B. +2, -1, E).
         * @param {number} score - Der numerische Score.
         * @returns {string} Der formatierte Score-String.
         */
        function formatScoreToPar(score) {
            if (score > 0) return `+${score}`;
            if (score === 0) return 'E';
            return score.toString();
        }

        // ===================================================================================
        // DYNAMIC RENDERING FUNCTIONS
        // ===================================================================================

        /**
         * Rendert die Tabelle "Aktuelle Spieler" im Organisator-Modus.
         */
        function renderPlayers() {
            playersTableBody.innerHTML = '';
            if (!course || !course.pars) return; // Warten, bis Platzdaten geladen sind
            const totalPar = course.pars.reduce((sum, p) => sum + p, 0);
            players.forEach((player) => {
                const playingHandicap = calculatePlayingHandicap(player.handicap, course.courseRating, course.slopeRating, totalPar);
                player.playingHandicap = playingHandicap;
                const row = playersTableBody.insertRow();
                row.innerHTML = `
                    <td>${player.name}</td>
                    <td>${player.handicap.toFixed(1)}</td>
                    <td>${player.playingHandicap}</td>
                    <td><button class="btn btn-danger btn-sm" data-player-id="${player.id}">Entfernen</button></td>
                `;
                row.querySelector('button').addEventListener('click', (e) => removePlayer(e.target.dataset.playerId));
            });
        }

        /**
         * Rendert die Score-Eingabetabelle im Organisator-Modus.
         */
        function renderScoresInput() {
            scoresTableBody.innerHTML = '';
            players.forEach(player => {
                const row = scoresTableBody.insertRow();
                row.innerHTML = `<td>${player.name}</td>`;
                for (let i = 1; i <= 18; i++) {
                    const cell = row.insertCell();
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '0';
                    input.max = '15';
                    input.className = 'score-input';
                    const dbScore = scores[player.id] && scores[player.id][`hole${i}`] !== undefined ? scores[player.id][`hole${i}`] : '';
                    input.value = dbScore;

                    if (dbScore !== '' && dbScore !== null && dbScore !== undefined) {
                        input.classList.add('bg-green-200');
                    }
                    input.id = `score-${player.id}-hole${i}`;
                    input.addEventListener('input', (e) => {
                        const newValue = e.target.value === '' ? null : parseInt(e.target.value);
                        const dbScore = scores[player.id] && scores[player.id][`hole${i}`];

                        if (newValue !== dbScore) {
                            e.target.classList.remove('bg-green-200');
                            e.target.classList.add('bg-red-200');
                        } else {
                            e.target.classList.remove('bg-red-200');
                            e.target.classList.add('bg-green-200');
                        }
                    });
                    cell.appendChild(input);
                }
            });
        }

        /**
         * Rendert die Score-Eingabetabelle für den angemeldeten Spieler.
         * @param {object} player - Das Spielerobjekt.
         */
        function renderPlayerScoresInput(player) {
            const tableBody = document.getElementById('playerScoresTableBody');
            tableBody.innerHTML = '';

            if (!course || !course.pars || !course.hcpIndices) return;

            const totalPar = course.pars.reduce((sum, p) => sum + p, 0);
            const playingHandicap = calculatePlayingHandicap(player.handicap, course.courseRating, course.slopeRating, totalPar);

            for (let i = 1; i <= 18; i++) {
                const holePar = course.pars[i - 1];
                const holeHcpIndex = course.hcpIndices[i - 1];
                const handicapStrokes = getHandicapStrokesPerHole(playingHandicap, holeHcpIndex);

                const row = tableBody.insertRow();
                row.className = 'text-center bg-white border-b hover:bg-gray-50';

                // Loch-Nummer
                const cellHole = row.insertCell();
                cellHole.textContent = `#${i}`;
                cellHole.className = 'font-bold';

                // Par und HC
                row.insertCell().textContent = holePar;
                row.insertCell().textContent = '/'.repeat(handicapStrokes);

                // Score-Eingabe mit +/- Buttons
                const cellScore = row.insertCell();
                const stepperContainer = document.createElement('div');
                stepperContainer.className = 'score-stepper';

                const minusBtn = document.createElement('button');
                minusBtn.textContent = '-';
                minusBtn.className = 'stepper-btn minus';
                minusBtn.type = 'button';

                const input = document.createElement('input');
                input.type = 'number';
                input.pattern = '[0-9]*'; // Für mobile numerische Tastatur
                input.inputMode = 'numeric'; // Stärkerer Hinweis für numerische Tastatur
                input.id = `player-score-hole-${i}`;
                input.min = '0';
                input.max = '15';
                input.className = 'score-input player-score-input'; // Kombination von Klassen
                const currentScore = scores[player.id] && scores[player.id][`hole${i}`] !== undefined ? scores[player.id][`hole${i}`] : '';
                input.value = currentScore;

                const plusBtn = document.createElement('button');
                plusBtn.textContent = '+';
                plusBtn.className = 'stepper-btn plus';
                plusBtn.type = 'button';

                stepperContainer.appendChild(minusBtn);
                stepperContainer.appendChild(input);
                stepperContainer.appendChild(plusBtn);
                cellScore.appendChild(stepperContainer);

                // Deaktiviere die Eingabeelemente, wenn die Eingabe gesperrt ist
                if (settings.isScoreEntryLocked) {
                    minusBtn.disabled = true;
                    input.disabled = true;
                    plusBtn.disabled = true;
                }

                // Event Listeners
                if (currentScore !== '' && currentScore !== null && currentScore !== undefined) {
                    input.classList.add('bg-green-200');
                }

                input.addEventListener('input', (e) => {
                    const newValue = e.target.value === '' ? null : parseInt(e.target.value);
                    const dbScore = scores[player.id] && scores[player.id][`hole${i}`];

                    if (newValue !== dbScore) {
                        e.target.classList.remove('bg-green-200');
                        e.target.classList.add('bg-red-200');
                        syncStatusEl.textContent = 'Ungespeicherte Änderungen';
                        syncStatusEl.classList.remove('text-green-600');
                        syncStatusEl.classList.add('text-red-600');
                    } else {
                        e.target.classList.remove('bg-red-200');
                        e.target.classList.add('bg-green-200');
                    }
                    updatePlayerTotalScore();
                    clearTimeout(debounceTimer);
                    debounceTimer = setTimeout(() => syncScoresAndProvideFeedback(false), 2000);
                });

                minusBtn.addEventListener('click', () => {
                    let currentValue = parseInt(input.value) || 0;
                    if (currentValue > 0) {
                        input.value = currentValue - 1;
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                });

                plusBtn.addEventListener('click', () => {
                    let currentValue = parseInt(input.value) || 0;
                    if (currentValue < 15) {
                        input.value = currentValue + 1;
                        input.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                });
            }
            updatePlayerTotalScore();
            syncScoresBtn.disabled = settings.isScoreEntryLocked;
            if (settings.isScoreEntryLocked) {
                 syncStatusEl.textContent = 'Eingabe gesperrt';
                 syncStatusEl.classList.remove('text-green-600');
                 syncStatusEl.classList.add('text-yellow-600');
            } else {
                syncStatusEl.textContent = 'Gespeichert';
                syncStatusEl.classList.add('text-green-600');
                syncStatusEl.classList.remove('text-red-600');
            }
        }

        /**
         * Berechnet und rendert die Haupt-Rangliste.
         */
        function calculateAndRenderLeaderboard() {
            const leaderboardData = [];
            if (!course || !course.pars) return;
            const totalPar = course.pars.reduce((sum, p) => sum + p, 0);

            players.forEach(player => {
                let totalStablefordPoints = 0;
                let totalStrokes = 0;
                let playerScores = scores[player.id] || {};
                const playingHandicap = calculatePlayingHandicap(player.handicap, course.courseRating, course.slopeRating, totalPar);

                for (let i = 1; i <= 18; i++) {
                    const grossScore = parseInt(playerScores[`hole${i}`]);
                    if (!isNaN(grossScore) && grossScore > 0) {
                        totalStablefordPoints += calculateStablefordPoints(grossScore, course.pars[i - 1], playingHandicap, course.hcpIndices[i - 1]);
                        totalStrokes += grossScore;
                    }
                }

                const brutto = totalStrokes > 0 ? totalStrokes - totalPar : null;
                const netto = totalStrokes > 0 ? brutto - playingHandicap : null;

                leaderboardData.push({
                    name: player.name,
                    totalPoints: totalStablefordPoints,
                    phc: player.handicap,
                    ehc: playingHandicap,
                    strokes: totalStrokes > 0 ? totalStrokes : '-',
                    brutto: brutto !== null ? formatScoreToPar(brutto) : '-',
                    netto: netto !== null ? formatScoreToPar(netto) : '-',
                });
            });

            leaderboardData.sort((a, b) => b.totalPoints - a.totalPoints);

            leaderboardTableBody.innerHTML = '';
            leaderboardData.forEach((player, index) => {
                let rank = index + 1;
                if (index > 0 && player.totalPoints === leaderboardData[index - 1].totalPoints) {
                    rank = leaderboardData[index-1].rank;
                }
                player.rank = rank;

                const row = leaderboardTableBody.insertRow();
                row.innerHTML = `
                    <td>${player.rank}.</td>
                    <td class="text-left">${player.name}</td>
                    <td>${player.totalPoints}</td>
                    <td>${player.phc.toFixed(1)}</td>
                    <td>${player.ehc}</td>
                    <td>${player.strokes}</td>
                    <td>${player.brutto}</td>
                    <td>${player.netto}</td>
                `;
            });

            if (leaderboardData.length === 0) {
                const row = leaderboardTableBody.insertRow();
                row.innerHTML = `<td colspan="8" class="text-center text-gray-500 py-4">Noch keine Ergebnisse vorhanden.</td>`;
            }
        }

        /**
         * Aktualisiert die Anzeige der Gesamtschlagzahl für den Spieler.
         */
        function updatePlayerTotalScore() {
            const inputs = document.querySelectorAll('#playerScoresTableBody .score-input');
            let total = 0;
            inputs.forEach(input => {
                const score = parseInt(input.value);
                if (!isNaN(score) && score > 0) {
                    total += score;
                }
            });
            document.getElementById('playerTotalScore').textContent = total;
        }

        /**
         * Validiert die HCP-Index-Eingaben in Echtzeit und markiert Duplikate.
         */
        function validateHcpInputs() {
            const hcpInputs = document.querySelectorAll('#courseDetailsTable input[id^="hcpIndex"]');
            const values = Array.from(hcpInputs).map(input => input.value);
            const duplicates = values.filter((item, index) => values.indexOf(item) !== index && item !== '');

            hcpInputs.forEach(input => {
                if (duplicates.includes(input.value) && input.value !== '') {
                    input.classList.add('border-red-500', 'border-2');
                } else {
                    input.classList.remove('border-red-500', 'border-2');
                }
            });
        }

        // ===================================================================================
        // FIREBASE DATABASE INTERACTIONS
        // ===================================================================================

        /**
         * Speichert die aktuellen Platzdaten in Firestore.
         */
        async function updateCourseData() {
            if (!authReady || !tournamentDocRef) return;
            await setDoc(tournamentDocRef, { course: course }, { merge: true });
        }

        /**
         * Speichert die globalen Turniereinstellungen in Firestore.
         */
        async function updateSettingsInDB() {
            if (!authReady || !tournamentDocRef) return;
            await setDoc(tournamentDocRef, { settings: settings }, { merge: true });
        }

        /**
         * Fügt einen neuen Spieler zum aktiven Turnier hinzu.
         * @param {object} player - Das Spielerobjekt.
         */
        async function addPlayerToDB(player) {
            if (!authReady || !tournamentDocRef) return;
            const playersCollectionRef = collection(tournamentDocRef, 'players');
            const newPlayerDocRef = doc(playersCollectionRef, player.id);
            await setDoc(newPlayerDocRef, player);
        }

        /**
         * Entfernt einen Spieler aus dem aktiven Turnier.
         * @param {string} playerId - Die ID des zu entfernenden Spielers.
         */
        async function removePlayerFromDB(playerId) {
            if (!authReady || !tournamentDocRef) return;
            const playerDocRef = doc(collection(tournamentDocRef, 'players'), playerId);
            await deleteDoc(playerDocRef);
        }

        /**
         * Synchronisiert die Scores des aktiven Spielers mit der Datenbank.
         * @param {boolean} showPopup - Ob nach Erfolg eine Nachrichtenbox angezeigt werden soll.
         */
        async function syncScoresAndProvideFeedback(showPopup) {
            if (!activePlayerId || !tournamentDocRef) return;

            syncStatusEl.textContent = 'Speichern...';
            syncStatusEl.classList.remove('text-green-600', 'text-red-600');

            const scoresToSave = {};
            let hasChanged = false;

            const inputs = document.querySelectorAll('#playerScoresTableBody .score-input');
            for (let i = 0; i < inputs.length; i++) {
                const input = inputs[i];
                const score = input.value === '' ? null : parseInt(input.value);
                const holeNumber = i + 1;
                const currentDbScore = scores[activePlayerId] ? scores[activePlayerId][`hole${holeNumber}`] : undefined;

                if (score !== currentDbScore) {
                    scoresToSave[`hole${holeNumber}`] = score;
                    hasChanged = true;
                }
            }

            if (!hasChanged) {
                if (showPopup) showMessageBox("Info", "Keine Änderungen zum Speichern.");
                syncStatusEl.textContent = 'Gespeichert';
                syncStatusEl.classList.add('text-green-600');
                return;
            }

            try {
                const playerDocRef = doc(collection(tournamentDocRef, 'players'), activePlayerId);
                await setDoc(playerDocRef, { scores: scoresToSave }, { merge: true });
                if (showPopup) {
                    showMessageBox("Erfolg", `Dein Score wurde erfolgreich synchronisiert!`);
                }
                 syncStatusEl.textContent = 'Gespeichert';
                 syncStatusEl.classList.add('text-green-600');
            } catch (error) {
                console.error("Sync failed:", error);
                if(showPopup) showMessageBox("Fehler", "Synchronisation fehlgeschlagen.");
                 syncStatusEl.textContent = 'Fehler beim Speichern';
                 syncStatusEl.classList.add('text-red-600');
            }
        }

        /**
         * Lädt die Liste der gespeicherten Turniere und füllt das Dropdown.
         */
        async function loadTournamentList() {
            if(!tournamentsCollectionRef) return;
            const querySnapshot = await getDocs(tournamentsCollectionRef);
            loadTournamentSelect.innerHTML = '';
            querySnapshot.forEach(doc => {
                 const option = document.createElement('option');
                 option.value = doc.id;
                 let tournamentName = doc.data().course.tournamentName || doc.id;
                 if (doc.id === currentTournamentId) {
                     tournamentName += " (live)";
                 }
                 option.textContent = tournamentName;
                 loadTournamentSelect.appendChild(option);
            });
        }

        // ===================================================================================
        // MAIN APP LOGIC & EVENT LISTENERS
        // ===================================================================================

        passwordSubmitBtn.addEventListener('click', () => {
            const enteredPassword = passwordInput.value;
            if (passwordModal._submitCallback) {
                passwordModal._submitCallback(enteredPassword);
            }
            hidePasswordModal();
        });

        passwordCancelBtn.addEventListener('click', () => {
            hidePasswordModal();
        });

        saveCourseBtn.addEventListener('click', async () => {
            course.tournamentName = tournamentNameInput.value.trim();
            course.courseName = courseNameInput.value.trim();
            course.courseRating = parseFloat(courseRatingInput.value);
            course.slopeRating = parseInt(slopeRatingInput.value);
            const newPars = [];
            const newHcpIndices = [];
            let isValid = true;
            if (isNaN(course.courseRating) || course.courseRating < 50 || course.courseRating > 80) { showMessageBox("Fehler", "Bitte geben Sie ein gültiges Course Rating (z.B. 72.0) ein."); isValid = false; }
            if (isNaN(course.slopeRating) || course.slopeRating < 55 || course.slopeRating > 155) { showMessageBox("Fehler", "Bitte geben Sie ein gültiges Slope Rating (55-155) ein."); isValid = false; }
            if (isValid) {
                for (let i = 1; i <= 18; i++) {
                    const parInput = document.getElementById(`par${i}`);
                    const hcpIndexInput = document.getElementById(`hcpIndex${i}`);
                    const par = parseInt(parInput.value);
                    const hcpIndex = parseInt(hcpIndexInput.value);
                    if (isNaN(par) || par < 3 || par > 5) { showMessageBox("Fehler", `Bitte geben Sie für Loch ${i} ein gültiges Par (3-5) ein.`); isValid = false; break; }
                    if (isNaN(hcpIndex) || hcpIndex < 1 || hcpIndex > 18) { showMessageBox("Fehler", `Bitte geben Sie für Loch ${i} einen gültigen HCP Index (1-18) ein.`); isValid = false; break; }
                    newPars.push(par);
                    newHcpIndices.push(hcpIndex);
                }
            }
            if (isValid) {
                const uniqueHcpIndices = new Set(newHcpIndices.filter(v => v));
                if (uniqueHcpIndices.size !== newHcpIndices.filter(v=>v).length) {
                    showMessageBox("Fehler", "Die HCP Indices müssen einzigartig sein.");
                    isValid = false;
                } else {
                    course.pars = newPars;
                    course.hcpIndices = newHcpIndices;
                    await updateCourseData();
                    showMessageBox("Erfolgreich", "Platz-Einstellungen gespeichert!");
                }
            }
        });

        addPlayerBtn.addEventListener('click', async () => {
            const name = playerNameInput.value.trim();
            const handicap = parseFloat(playerHandicapInput.value);
            if (!name) { showMessageBox("Fehler", "Bitte geben Sie einen Spielernamen ein."); return; }
            if (isNaN(handicap) || handicap < 0 || handicap > 54) { showMessageBox("Fehler", "Bitte geben Sie einen gültigen Handicap Index (0.0-54.0) ein."); return; }
            if (players.some(p => p.name.toLowerCase() === name.toLowerCase())) { showMessageBox("Fehler", "Ein Spieler mit diesem Namen existiert bereits. Bitte wählen Sie einen anderen Namen."); return; }
            const newPlayer = { id: Date.now().toString(), name: name, handicap: handicap, scores: {} };
            await addPlayerToDB(newPlayer);
            playerNameInput.value = '';
            playerHandicapInput.value = '18.0';
            showMessageBox("Erfolgreich", `${name} wurde hinzugefügt.`);
        });

        function removePlayer(playerId) {
            removePlayerFromDB(playerId);
            showMessageBox("Erfolgreich", "Spieler wurde entfernt.");
        }

        messageBoxOverlay.addEventListener('click', hideMessageBox);
        organizerModeBtnBottom.addEventListener('click', () => switchMode('organizer'));
        playerModeBtn.addEventListener('click', () => switchMode('player'));
        playerModeBtnBottom.addEventListener('click', () => switchMode('player'));


        playerLoginBtn.addEventListener('click', () => {
            const selectedPlayerId = playerSelect.value;
            if (selectedPlayerId) {
                loginPlayer(selectedPlayerId, true);
            } else {
                showMessageBox("Fehler", "Bitte wählen Sie einen Spieler aus der Liste aus.");
            }
        });

        calculateScoresBtn.addEventListener('click', async () => {
            if (!organizerSessionActive) {
                showMessageBox("Fehler", "Sie sind nicht als Organisator angemeldet.");
                return;
            }

            const batch = writeBatch(db);
            players.forEach((player) => {
                const playerDocRef = doc(collection(tournamentDocRef, 'players'), player.id);
                const scoresToUpdate = {};
                 for (let i = 1; i <= 18; i++) {
                    const input = document.querySelector(`#score-${player.id}-hole${i}`);
                    if(input){
                        scoresToUpdate[`hole${i}`] = input.value === '' ? null : parseInt(input.value);
                    }
                }
                batch.set(playerDocRef, { scores: scoresToUpdate }, { merge: true });
            });
            await batch.commit();
            showMessageBox("Erfolg", "Rangliste aktualisiert.");
        });

        syncScoresBtn.addEventListener('click', async () => {
            clearTimeout(debounceTimer);
            await syncScoresAndProvideFeedback(true);
        });

        liveScoreBtn.addEventListener('click', () => {
            if (activePlayerId) {
                const inputs = document.querySelectorAll('#playerScoresTableBody .score-input');
                const hasUnsyncedChanges = Array.from(inputs).some(input => input.classList.contains('bg-red-200'));
                if (hasUnsyncedChanges) {
                    showMessageBox("Info", "Bitte synchronisieren Sie zuerst alle Änderungen.");
                    return;
                }
            }

            const leaderboardData = [];
            if (!course.pars) return;
            const totalPar = course.pars.reduce((sum, p) => sum + p, 0);

            players.forEach(player => {
                let totalStablefordPoints = 0;
                let totalStrokes = 0;
                let playerScores = scores[player.id] || {};
                const playingHandicap = calculatePlayingHandicap(player.handicap, course.courseRating, course.slopeRating, totalPar);

                for (let i = 1; i <= 18; i++) {
                    const grossScore = parseInt(playerScores[`hole${i}`]);
                    if (!isNaN(grossScore) && grossScore > 0) {
                        totalStablefordPoints += calculateStablefordPoints(grossScore, course.pars[i - 1], playingHandicap, course.hcpIndices[i - 1]);
                        totalStrokes += grossScore;
                    }
                }

                const brutto = totalStrokes > 0 ? totalStrokes - totalPar : null;
                const netto = totalStrokes > 0 ? brutto - playingHandicap : null;

                leaderboardData.push({
                    name: player.name,
                    totalPoints: totalStablefordPoints,
                    phc: player.handicap,
                    ehc: playingHandicap,
                    strokes: totalStrokes > 0 ? totalStrokes : '-',
                    brutto: brutto !== null ? formatScoreToPar(brutto) : '-',
                    netto: netto !== null ? formatScoreToPar(netto) : '-',
                });
            });

            leaderboardData.sort((a, b) => b.totalPoints - a.totalPoints);

            let leaderboardHtml = `
                <h4 class="text-lg font-semibold mt-4 mb-2">${course.tournamentName || "Live Score"}</h4>
                <div class="table-container">
                    <table class="w-full text-sm text-left text-gray-700">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-50 rounded-lg">
                            <tr>
                                <th scope="col" class="px-3 py-2">#</th>
                                <th scope="col" class="px-3 py-2 text-left">Spieler</th>
                                <th scope="col" class="px-3 py-2">SF</th>
                                <th scope="col" class="px-3 py-2">PHC</th>
                                <th scope="col" class="px-3 py-2">EHC</th>
                                <th scope="col" class="px-3 py-2">Strokes</th>
                                <th scope="col" class="px-3 py-2">Brutto</th>
                                <th scope="col" class="px-3 py-2">Netto</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            leaderboardData.forEach((player, index) => {
                 let rank = index + 1;
                if (index > 0 && player.totalPoints === leaderboardData[index - 1].totalPoints) {
                    rank = leaderboardData[index-1].rank;
                }
                player.rank = rank;

                leaderboardHtml += `
                    <tr class="bg-white border-b hover:bg-gray-50 text-center">
                        <td class="px-3 py-2 font-medium text-gray-900 whitespace-nowrap">${player.rank}.</td>
                        <td class="px-3 py-2 text-left">${player.name}</td>
                        <td class="px-3 py-2 font-bold">${player.totalPoints}</td>
                        <td class="px-3 py-2">${player.phc.toFixed(1)}</td>
                        <td class="px-3 py-2">${player.ehc}</td>
                        <td class="px-3 py-2">${player.strokes}</td>
                        <td class="px-3 py-2">${player.brutto}</td>
                        <td class="px-3 py-2">${player.netto}</td>
                    </tr>
                `;
            });
            leaderboardHtml += `
                        </tbody>
                    </table>
                </div>
            `;
            showMessageBox("Live Score", leaderboardHtml);
        });

        playerSaveScoresBtn.addEventListener('click', async () => {
            if (!activePlayerId) {
                showMessageBox("Fehler", "Bitte melden Sie sich zuerst an.");
                return;
            }
            const inputs = document.querySelectorAll('#playerScoresTableBody .score-input');
            const hasUnsyncedChanges = Array.from(inputs).some(input => input.classList.contains('bg-red-200'));

            if (hasUnsyncedChanges) {
                showMessageBox("Info", "Bitte synchronisieren Sie zuerst alle Änderungen.");
                return;
            }

            const activePlayer = players.find(p => p.id === activePlayerId);
            const scoresToSave = scores[activePlayerId] || {};
            const totalPar = course.pars.reduce((sum, p) => sum + p, 0);
            const playingHandicap = calculatePlayingHandicap(activePlayer.handicap, course.courseRating, course.slopeRating, totalPar);

            // Summen-Variablen
            let outParSum = 0, outScoreSum = 0, outSfSum = 0;
            let inParSum = 0, inScoreSum = 0, inSfSum = 0;

            // Zuerst Gesamtpunkte für die Überschrift berechnen
            let totalStablefordPoints = 0;
            for (let i = 1; i <= 18; i++) {
                const scoreValue = scoresToSave[`hole${i}`];
                const grossScore = (scoreValue !== null && scoreValue !== undefined) ? parseInt(scoreValue) : NaN;
                if (!isNaN(grossScore) && grossScore > 0) {
                     totalStablefordPoints += calculateStablefordPoints(grossScore, course.pars[i - 1], playingHandicap, course.hcpIndices[i - 1]);
                }
            }

            let perHolePointsHtml = `
                <h3 class="text-lg font-bold mb-4">Gesamt Stableford Punkte: ${totalStablefordPoints}</h3>
                <div class="table-container">
                    <table class="w-full text-sm text-left text-gray-700">
                        <thead class="text-xs text-gray-700 uppercase bg-gray-50 rounded-lg">
                            <tr>
                                <th scope="col" class="px-3 py-2 text-center">#</th>
                                <th scope="col" class="px-3 py-2 text-center">PAR</th>
                                <th scope="col" class="px-3 py-2 text-center">HCP /</th>
                                <th scope="col" class="px-3 py-2 text-center">SC</th>
                                <th scope="col" class="px-3 py-2 text-center">SF</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            for (let i = 1; i <= 18; i++) {
                const holePar = course.pars[i - 1];
                const holeHcpIndex = course.hcpIndices[i - 1];
                const scoreValue = scoresToSave[`hole${i}`];
                const grossScore = (scoreValue !== null && scoreValue !== undefined) ? parseInt(scoreValue) : NaN;

                let stablefordPoints = 0;
                if (!isNaN(grossScore) && grossScore > 0) {
                    stablefordPoints = calculateStablefordPoints(grossScore, holePar, playingHandicap, holeHcpIndex);
                }

                const handicapStrokesForHole = getHandicapStrokesPerHole(playingHandicap, holeHcpIndex);

                // Zu den Summen addieren
                if (i <= 9) {
                    outParSum += holePar;
                    if (!isNaN(grossScore) && grossScore > 0) {
                        outScoreSum += grossScore;
                        outSfSum += stablefordPoints;
                    }
                } else {
                    inParSum += holePar;
                    if (!isNaN(grossScore) && grossScore > 0) {
                        inScoreSum += grossScore;
                        inSfSum += stablefordPoints;
                    }
                }

                perHolePointsHtml += `
                    <tr class="bg-white border-b hover:bg-gray-50 text-center">
                        <td class="px-3 py-2 font-medium text-gray-900 whitespace-nowrap">#${i}</td>
                        <td class="px-3 py-2">${holePar}</td>
                        <td class="px-3 py-2">${'/'.repeat(handicapStrokesForHole) || '-'}</td>
                        <td class="px-3 py-2">${(!isNaN(grossScore) && grossScore > 0) ? grossScore : '-'}</td>
                        <td class="px-3 py-2 font-bold">${stablefordPoints}</td>
                    </tr>
                `;

                // Summenzeile "OUT" nach Loch 9 einfügen
                if (i === 9) {
                    perHolePointsHtml += `
                        <tr class="bg-gray-100 font-bold text-center">
                            <td class="px-3 py-2">OUT</td>
                            <td class="px-3 py-2">${outParSum}</td>
                            <td class="px-3 py-2">-</td>
                            <td class="px-3 py-2">${outScoreSum > 0 ? outScoreSum : '-'}</td>
                            <td class="px-3 py-2">${outSfSum}</td>
                        </tr>
                    `;
                }
            }

            // Summenzeilen "IN" und "TOTAL" am Ende einfügen
             perHolePointsHtml += `
                <tr class="bg-gray-100 font-bold text-center">
                    <td class="px-3 py-2">IN</td>
                    <td class="px-3 py-2">${inParSum}</td>
                    <td class="px-3 py-2">-</td>
                    <td class="px-3 py-2">${inScoreSum > 0 ? inScoreSum : '-'}</td>
                    <td class="px-3 py-2">${inSfSum}</td>
                </tr>
                <tr class="bg-gray-200 font-extrabold text-center">
                    <td class="px-3 py-2">TOTAL</td>
                    <td class="px-3 py-2">${outParSum + inParSum}</td>
                    <td class="px-3 py-2">-</td>
                    <td class="px-3 py-2">${(outScoreSum + inScoreSum) > 0 ? (outScoreSum + inScoreSum) : '-'}</td>
                    <td class="px-3 py-2">${outSfSum + inSfSum}</td>
                </tr>
            `;

            perHolePointsHtml += `
                        </tbody>
                    </table>
                </div>
            `;
            showMessageBox("Deine Scorecard", perHolePointsHtml);
        });

        organizerSyncBtn.addEventListener('click', () => {
            if (!organizerSessionActive) {
                showMessageBox("Fehler", "Sie sind nicht als Organisator angemeldet.");
                return;
            }
            calculateAndRenderLeaderboard();
        });


        /**
         * Hauptinitialisierungsfunktion: Setzt Firebase auf, meldet den Benutzer anonym an und startet die Echtzeit-Listener.
         */
        async function initFirebase() {
            try {
                if (!getApps().length) {
                    app = initializeApp(firebaseConfig);
                } else {
                    app = getApps()[0];
                }

                auth = getAuth(app);
                db = getFirestore(app);
                setLogLevel('debug');
                getAnalytics(app);

                await signInAnonymously(auth);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        authReady = true;
                        tournamentsCollectionRef = collection(db, `/artifacts/${appId}/public/data/tournaments`);

                        // Letztes geladenes Turnier aus dem Speicher holen
                        currentTournamentId = localStorage.getItem('golfStablefordCurrentTournamentId') || 'live_tournament';

                        if (currentTournamentId) {
                            setupListeners(currentTournamentId);
                        } else {
                             playerWelcomeMessage.textContent = "Willkommen! Bitte lade ein Turnier oder bitte den Organisator, eines zu erstellen.";
                        }
                        loadTournamentList();

                    } else {
                        console.log("User is signed out.");
                    }
                });

            } catch (e) {
                console.error("Firebase init failed:", e);
                showMessageBox("Fehler", "Firebase-Initialisierung fehlgeschlagen.");
            }
        }

        /**
         * Baut die Echtzeit-Listener für ein bestimmtes Turnier auf.
         * @param {string} tournamentId Die ID des Turniers, auf das gehört werden soll.
         */
        function setupListeners(tournamentId) {
             // Alten Listener abbestellen, falls vorhanden
            if (unsubscribeTournament) unsubscribeTournament();
            if (unsubscribePlayers) unsubscribePlayers();

            tournamentDocRef = doc(tournamentsCollectionRef, tournamentId);

            unsubscribeTournament = onSnapshot(tournamentDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    course = data.course || {};
                    settings = data.settings || { isScoreEntryLocked: false, isLiveScoreVisible: true };

                    tournamentNameInput.value = course.tournamentName || '';
                    courseNameInput.value = course.courseName || '';
                    courseRatingInput.value = course.courseRating;
                    slopeRatingInput.value = course.slopeRating;
                    if(course.pars && course.hcpIndices) {
                        course.pars.forEach((par, i) => {
                            const input = document.getElementById(`par${i + 1}`);
                            if (input) input.value = par;
                        });
                        course.hcpIndices.forEach((hcpIndex, i) => {
                            const input = document.getElementById(`hcpIndex${i + 1}`);
                            if (input) input.value = hcpIndex;
                        });
                    } else {
                         // Default-Werte setzen, falls nicht vorhanden
                        course.pars = Array(18).fill(4);
                        course.hcpIndices = Array.from({length: 18}, (_, i) => i + 1);
                    }

                    updatePageTitles();
                    updateInfoBox();
                    applyTournamentSettings();

                    // Spieler-Listener separat aufbauen
                    const playersCollectionRef = collection(tournamentDocRef, 'players');
                    unsubscribePlayers = onSnapshot(playersCollectionRef, (playersSnapshot) => {
                        players = [];
                        scores = {};
                        playersSnapshot.forEach(playerDoc => {
                            if (playerDoc.id !== 'dummy') {
                                const playerData = playerDoc.data();
                                players.push({ id: playerDoc.id, ...playerData });
                                scores[playerDoc.id] = playerData.scores || {};
                            }
                        });
                        updateUIWithNewData();
                    });
                } else {
                    console.warn(`Tournament with ID "${tournamentId}" does not exist.`);
                    currentTournamentId = null;
                    localStorage.removeItem('golfStablefordCurrentTournamentId');
                    showMessageBox("Fehler", "Das geladene Turnier existiert nicht mehr. Bitte wählen Sie ein anderes in der Turnierverwaltung.", () => {
                        showTournamentAdminModal();
                    });
                }
            }, (error) => console.error("Error listening to tournament data:", error));
        }

        function updateUIWithNewData() {
            renderPlayers();
            renderScoresInput();
            calculateAndRenderLeaderboard();
            populatePlayerSelect();
            updateInfoBox();

            const savedPlayerId = localStorage.getItem('golfStablefordActivePlayerId');
            if (currentMode === 'player' && savedPlayerId && players.some(p => p.id === savedPlayerId)) {
                loginPlayer(savedPlayerId, false);
            } else if (currentMode === 'player') {
                activePlayerId = null;
                localStorage.removeItem('golfStablefordActivePlayerId');
                updateInfoBox();
            }
        }


        // Initialisiert die App, wenn das DOM vollständig geladen ist.
        document.addEventListener('DOMContentLoaded', () => {
            initFirebase();

            // Globale Event Listener
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Enter') {
                    if (!document.getElementById('messageBox').classList.contains('hidden')) {
                        event.preventDefault();
                        document.getElementById('messageBoxCloseBtn').click();
                    }
                    else if (!passwordModal.classList.contains('hidden')) {
                        event.preventDefault();
                        passwordSubmitBtn.click();
                    }
                }
            });

            // Listener für die Live-Validierung der HCP-Indizes
            for (let i = 1; i <= 18; i++) {
                const hcpInput = document.getElementById(`hcpIndex${i}`);
                if(hcpInput) {
                    hcpInput.addEventListener('input', validateHcpInputs);
                }
            }

            // Listener für die Turniersteuerungs-Schalter
            lockScoresToggle.addEventListener('change', () => {
                settings.isScoreEntryLocked = lockScoresToggle.checked;
                updateSettingsInDB();
            });

            showLiveScoreToggle.addEventListener('change', () => {
                settings.isLiveScoreVisible = showLiveScoreToggle.checked;
                updateSettingsInDB();
            });

            // Listener für die live Titelaktualisierung
            tournamentNameInput.addEventListener('input', updatePageTitles);

            // Listener für Turnierverwaltung
             tournamentAdminBtn.addEventListener('click', () => {
                showPasswordModal((password) => {
                    if (password === ORGANIZER_PASSWORD) {
                        showTournamentAdminModal();
                    } else {
                        showMessageBox("Fehler", "Falsches Passwort.");
                    }
                });
            });

            closeAdminModalBtn.addEventListener('click', hideTournamentAdminModal);

            createTournamentBtn.addEventListener('click', async () => {
                const name = newTournamentNameInput.value.trim();
                if (!name) {
                    showMessageBox("Fehler", "Bitte geben Sie einen Namen für das neue Turnier ein.");
                    return;
                }
                const newTournamentId = name.replace(/\s+/g, '-').toLowerCase() + '-' + Date.now();
                const defaultCourse = { tournamentName: name, courseName: '', courseRating: 72.0, slopeRating: 120, pars: Array(18).fill(4), hcpIndices: Array.from({ length: 18 }, (_, i) => i + 1) };
                const defaultSettings = { isScoreEntryLocked: false, isLiveScoreVisible: true };

                await setDoc(doc(tournamentsCollectionRef, newTournamentId), {
                    course: defaultCourse,
                    settings: defaultSettings,
                });

                const playersCollectionRef = collection(db, `/artifacts/${appId}/public/data/tournaments/${newTournamentId}/players`);
                await setDoc(doc(playersCollectionRef, 'dummy'), { exists: true });

                await loadTournamentAsLive(newTournamentId);
                hideTournamentAdminModal();
                showMessageBox("Erfolg", `Turnier "${name}" wurde erstellt und ist jetzt für alle Spieler live.`);
                loadTournamentList();
            });

            loadTournamentBtn.addEventListener('click', async () => {
                const selectedTournamentId = loadTournamentSelect.value;
                if (!selectedTournamentId) {
                    showMessageBox("Fehler", "Bitte wählen Sie ein Turnier zum Laden aus.");
                    return;
                }
                await loadTournamentAsLive(selectedTournamentId);
                hideTournamentAdminModal();
                showMessageBox("Erfolg", `Turnier "${loadTournamentSelect.options[loadTournamentSelect.selectedIndex].text}" wurde für alle Spieler geladen.`);
            });

            async function loadTournamentAsLive(tournamentIdToLoad) {
                 // Daten des gespeicherten Turniers holen
                const savedTournamentDoc = await getDoc(doc(tournamentsCollectionRef, tournamentIdToLoad));
                if (savedTournamentDoc.exists()) {
                    const dataToLoad = savedTournamentDoc.data();

                    // Daten in das 'live_tournament' Dokument schreiben
                    const liveTournamentRef = doc(tournamentsCollectionRef, 'live_tournament');
                    await setDoc(liveTournamentRef, {
                        course: dataToLoad.course,
                        settings: dataToLoad.settings || { isScoreEntryLocked: false, isLiveScoreVisible: true }
                    });

                    // Spieler-Subcollection kopieren
                    const savedPlayersRef = collection(tournamentsCollectionRef, `${tournamentIdToLoad}/players`);
                    const livePlayersRef = collection(tournamentsCollectionRef, `live_tournament/players`);
                    const savedPlayerDocs = await getDocs(savedPlayersRef);

                    // Zuerst alle alten Spieler im Live-Turnier löschen
                    const currentLivePlayers = await getDocs(livePlayersRef);
                    const deleteBatch = writeBatch(db);
                    currentLivePlayers.forEach(d => deleteBatch.delete(d.ref));
                    await deleteBatch.commit();

                    // Dann neue Spieler hinzufügen
                    const addBatch = writeBatch(db);
                    savedPlayerDocs.forEach(d => {
                        if(d.id !== 'dummy') { // Dummy-Dokument nicht kopieren
                           addBatch.set(doc(livePlayersRef, d.id), d.data());
                        }
                    });
                    await addBatch.commit();

                    currentTournamentId = 'live_tournament';
                    localStorage.setItem('golfStablefordCurrentTournamentId', currentTournamentId);
                    setupListeners(currentTournamentId);
                } else {
                     showMessageBox("Fehler", "Das ausgewählte Turnier konnte nicht gefunden werden.");
                }
            }

            deleteTournamentBtn.addEventListener('click', async () => {
                const selectedTournamentId = loadTournamentSelect.value;
                 if (!selectedTournamentId) {
                    showMessageBox("Fehler", "Bitte wählen Sie ein Turnier zum Löschen aus.");
                    return;
                }
                showMessageBox("Bestätigung", `Möchten Sie das Turnier "${loadTournamentSelect.options[loadTournamentSelect.selectedIndex].text}" wirklich unwiderruflich löschen?`, async () => {
                    // Sub-Collection löschen
                     const playersCollectionRef = collection(db, `/artifacts/${appId}/public/data/tournaments/${selectedTournamentId}/players`);
                     const playerDocs = await getDocs(playersCollectionRef);
                     const batch = writeBatch(db);
                     playerDocs.forEach(d => batch.delete(d.ref));
                     await batch.commit();

                    // Hauptdokument löschen
                    await deleteDoc(doc(tournamentsCollectionRef, selectedTournamentId));
                    showMessageBox("Erfolg", "Turnier wurde gelöscht.");
                    loadTournamentList();

                    if(currentTournamentId === selectedTournamentId) {
                        currentTournamentId = null;
                        localStorage.removeItem('golfStablefordCurrentTournamentId');
                        location.reload();
                    }
                });
            });

        });
    </script>
</body>
</html>
